 //****************************************************************************************************
//Программа-эмулятор комплекса ИПК
//****************************************************************************************************

//****************************************************************************************************
//подключаемые библиотеки
//****************************************************************************************************

#include <stdint.h>
#include <sys/neutrino.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "c7841.h"

//****************************************************************************************************
//сигналы
//****************************************************************************************************
void Signal_Exit(int32_t s_code);//уничтожение процесса

//****************************************************************************************************
//глобальные переменные
//****************************************************************************************************

//****************************************************************************************************
//прототипы функций
//****************************************************************************************************

//****************************************************************************************************
//функции
//****************************************************************************************************

//----------------------------------------------------------------------------------------------------
//основная функция программы
//----------------------------------------------------------------------------------------------------
int main(int32_t argc, char *argv[]) 
{
 //разрешаем доступ потоку к ресурсам аппаратуры
 ThreadCtl(_NTO_TCTL_IO,NULL);
 //подключим сигналы
 printf("Connecting signals.\r\n");
 signal(SIGINT,Signal_Exit);
 signal(SIGTERM,Signal_Exit);
 signal(SIGKILL,Signal_Exit);
 signal(SIGCLD,Signal_Exit);
 signal(SIGQUIT,Signal_Exit); 

 C7841 c7841;
 c7841.Init();
 
 uint32_t arbitration=0xFFFFFFFF;
 uint32_t arbitration_mask=0xFFFFFFFF;//маска инверсная?
 
 C7841CANChannel c7841CANChannel(true,arbitration,arbitration_mask,C7841CANChannel::CAN7841_SPEED_500KBS);
 
 c7841.CANConfig(0,c7841CANChannel);
 c7841.CANConfig(1,c7841CANChannel);
 
 C7841CANPackage c7841CANPackage(0,false,8);
 for(uint8_t n=0;n<c7841CANPackage.Length;n++)c7841CANPackage.Data[n]=n; 

 while(1)
 {  
  delay(1000);
  std::vector<C7841CANPackage> vector_C7841CANPackage;
  c7841.GetReceivedPackage(vector_C7841CANPackage);
  size_t size=vector_C7841CANPackage.size();
  if (size>0) printf("Received %i \r\n",size);
  for(size_t v=0;v<size;v++)
  {
   printf("Channel %i ",vector_C7841CANPackage[v].ChannelIndex);
   printf("Arb:%08x ",vector_C7841CANPackage[v].Arbitration);
   printf("Len:%02x Data:",vector_C7841CANPackage[v].Length);
   for(uint8_t n=0;n<vector_C7841CANPackage[v].Length;n++) printf("%02x ",vector_C7841CANPackage[v].Data[n]);
   printf("\r\n");
  }
 } 
 return(EXIT_SUCCESS);
}

//****************************************************************************************************
//сигналы
//****************************************************************************************************

//----------------------------------------------------------------------------------------------------
//уничтожение подчинённого процесса
//----------------------------------------------------------------------------------------------------
void Signal_Exit(int32_t s_code)
{
 printf("Receive signal TERM.\r\n");
 exit(EXIT_SUCCESS);
}